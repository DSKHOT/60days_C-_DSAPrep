Time Complexity: The time complexity of an algorithm quantifies the amount of time taken by an algorithm to run as a function of the length of the input. Note that the time to run is a function of the length of the input and not the actual execution time of the machine on which the algorithm is running on.

calculate the time complexity of the below algorithm:

count = 0
for (int i = N; i > 0; i /= 2)
  for (int j = 0; j < i; j++)
    count++;
This is a tricky case. In the first look, it seems like the complexity is O(N * log N). N for the j′s loop and log(N) for i′s loop. But it’s wrong. Let’s see why.

Think about how many times count++ will run. 

When i = N, it will run N times.
When i = N / 2, it will run N / 2 times.
When i = N / 4, it will run N / 4 times.
And so on.
The total number of times count++ will run is N + N/2 + N/4+…+1= 2 * N. So the time complexity will be O(N).

Input Length	|  Worst Accepted Time Complexity |Usually type of solutions
10-12	  		  |	O(N!)	            		    | Recursion and backtracking
15-18			    |	O(2^N * N)	        		  |Recursion, backtracking, and bit manipulation
18-22			    |	O(2^N * N)	        		  |Recursion, backtracking, and bit manipulation
30-40			    |	O(2^N/2 * N)	    		    |Meet in the middle, Divide and Conquer
100				    |	O(N^4)	            		  |Dynamic programming, Constructive
400	    		  |	O(N^3)	            		  |Dynamic programming, Constructive
2K	    		  |	O(N^2* log N)	    		    |Dynamic programming, Binary Search, Sorting,  Divide and Conquer
10K	    		  |	O(N^2)	            		  |Dynamic programming, Graph, Trees, Constructive
1M	    		  |	O(N* log N)	        		  |Sorting, Binary Search, Divide and Conquer
100M			    |	O(N), O(log N), O(1)		  | Constructive, Mathematical, Greedy Algorithms


Space Complexity: The space complexity of an algorithm quantifies the amount of space taken by an algorithm to run as a function of the length of the input.

The pseudo-code for problem to find the frequency of array elements is as follows: 

int freq[n];
int a[n];

for(int i = 0; i<n; i++)
{
   cin>>a[i];
   freq[a[i]]++;
}

Here two arrays of length N, and variable i are used in the algorithm so, the total space used is N * c + N * c + 1 * c = 2N * c + c, where c is a unit space taken. For many inputs, constant c is insignificant, and it can be said that the space complexity is O(N).
